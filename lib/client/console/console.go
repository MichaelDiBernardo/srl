package console

import (
	"github.com/MichaelDiBernardo/srl/lib/game"
	"github.com/nsf/termbox-go"
)

// A console client.
type Console struct {
	display      display
	mapPanel     *mapPanel
	messagePanel *messagePanel
}

// Create a new console client.
func New() *Console {
	display := &tbdisplay{}
	return &Console{
		display:      display,
		mapPanel:     newMapPanel(display),
		messagePanel: newMessagePanel(6, display),
	}
}

// Init the console client.
func (c *Console) Init() error {
	return c.display.Init()
}

// Render the current screen on this console.
func (c *Console) Render(g *game.Game) {
	c.display.Clear(termbox.ColorDefault, termbox.ColorDefault)
	c.mapPanel.Render(g)
	c.messagePanel.Render(g)
	c.display.Flush()
}

// Handle an event generated by the game after the last command.
func (c *Console) Handle(ev game.Event) {
	c.mapPanel.Handle(ev)
	c.messagePanel.Handle(ev)
}

// Get the next command from the player to be sent to the game instance.
func (c *Console) NextCommand() game.Command {
	keymap := map[rune]game.Command{
		'h': game.CommandMoveW,
		'j': game.CommandMoveS,
		'k': game.CommandMoveN,
		'l': game.CommandMoveE,
		'q': game.CommandQuit,
	}
	for {
		tboxev := c.display.PollEvent()

		if tboxev.Type != termbox.EventKey || tboxev.Key != 0 {
			continue
		}

		srlev := keymap[tboxev.Ch]
		if srlev != 0 {
			return srlev
		}
	}
}

// Tear down the console client.
func (c *Console) Close() {
	c.display.Close()
}
