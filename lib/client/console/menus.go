package console

import (
	"fmt"
	"github.com/MichaelDiBernardo/srl/lib/game"
	"github.com/nsf/termbox-go"
)

// The inventory screen.
type inventoryScreen struct {
	display display
	menu    panel
}

// Create a new inventory screen.
func newInventoryScreen(display display) *inventoryScreen {
	return &inventoryScreen{
		display: display,
		menu:    newMenuPanel(display),
	}
}

// Render the inventory screen.
func (inv *inventoryScreen) Render(g *game.Game) {
	inv.menu.Render(g)
}

// Handle an event generated by the game after the last command.
func (inv *inventoryScreen) Handle(ev game.Event) {
}

// Get the next command from the player to be sent to the game instance.
func (inv *inventoryScreen) NextCommand() game.Command {
	for {
		tboxev := inv.display.PollEvent()
		if tboxev.Type == termbox.EventKey && tboxev.Key == termbox.KeyEsc {
			return game.CommandSeeHud
		}
	}
}

// Panel that renders the inventory.
type menuPanel struct {
	display display
}

// Create a new menuPanel.
func newMenuPanel(display display) *menuPanel {
	return &menuPanel{display: display}
}

// Listens to nothing.
func (m *menuPanel) Handle(e game.Event) {
}

// Render the menu.
func (m *menuPanel) Render(g *game.Game) {
	items := g.Player.Packer.Inventory().Items
	m.display.Write(0, 0, "Inventory", termbox.ColorWhite, termbox.ColorBlack)
	i := 0
	for e := items.Back(); e != nil; e = e.Prev() {
		item := e.Value.(*game.Obj)
		m.display.Write(1, 1+i, fmt.Sprintf("%v - %v", alphabet[i], item.Spec.Name), termbox.ColorWhite, termbox.ColorBlack)
		i++
	}
}
